\documentclass[a4paper,12pt]{article}


% add more packages if necessary
\usepackage{xspace}
%\usepackage{graphicx}
%\usepackage{xcolor}
%\usepackage{hyperref}


\newcommand{\groupname}{Panda\xspace}


\title{
Project Report \\ 
Group Pandas \\
\vspace{5mm}
\large Java and C\# in depth, Spring 2013
}
\author{
Christian Klauser \\
Sander Schaffner \\
Roger Walt
}
\date{\today}



\begin{document}
\maketitle

\section{Introduction}

This document describes the design and implementation of the \emph{Panda Virtual File System} of group \emph{Pandas}. The project is part of the course \emph{Java and C\# in depth} at ETH Zurich. The following sections describe each project phase, listing the requirements that were implemented and the design decisions taken. The last section describes a use case of using the \emph{Panda Virtual File System}.

% PART I: VFS CORE
% --------------------------------------

\section{VFS Core}

The VFS Core (assembly Panda.Core) is the actual implementation of the virtual file system. It is a library that manages directories and files within virtual as we are used to it from other file systems. Clients are presented with a simple API that models the virtual file system as a hierarchical structure. Implementation details are well hidden and the libraries design lends itself to isolated testing of its individual components.

\subsection{Design}

%\emph{Give an overview of the design of this part and describe in general terms how the implementation works. You can mention design patterns used, class diagrams, definition of custom file formats, network protocols, or anything else that helps understand the implementation.}\\

The VFS Core is divided in three layers. 
This makes the library easier to understand and maintain, as the individual layers need not concern themselves with the entire complexity of virtual file systems as a whole.

We chose to simplify storage management by dividing the available space in a virtual disk into evenly sized \emph{blocks}. 
One of our layers, the block API, is exclusively task with the reading and writing of these blocks to and from ``raw'' storage space. 
The boundaries of the block layer define the two other layers: the file system layer, implemented on top of the block API, and the I/O layer, which manages the actual storage (reading/writing from the host file system)

\subsubsection{I/O layer}

On this level we store raw data. Implementations of the I/O layer implement the \texttt{IPersistenceSpace} and \texttt{IRawPersistenceSpace} interfaces in the \texttt{Panda.Core.IO} namespace. 
Our main implementation uses \emph{memory mapped files} to read from and write to the disk.
From the perspective of the block layer, a \emph{storage space} is simply a large block of main memory that gets ``magically'' persisted to disk.
The I/O abstraction is not perfect, as it hands out raw (unsafe) pointers and therefore must be backed by contiguous memory.

For debugging and unit testing purposes, we also implemented a persistence space that is not backed by a file on disk.
This has proven useful as we did not have to deal with the creation and clean up of temporary files.

\subsubsection{Block layer}

The purpose of the block layer is to present a structured view of the raw storage space below. 
It divides the underlying space into evenly sized block (block size can be configured per disk), which it uses to store both file system meta information as well as the actual file contents themselves.

Blocks are addressed by their index (how many blocks come before them) as opposed to their absolute byte offset.
This addressing has the advantage that it is independent of the underlying block size. 

The block layer is exposed via the interface \texttt{Panda.Core.Blocks.IBlockManager}.
Implementations of this interface hand out instances of \texttt{Panda.Core.Blocks.IBlock} (or derived interfaces), which are each responsible for a single block of the virtual disk.

Given such an \texttt{IBlock}, the user can read/write fields of the block in a safe manner. 
Pointer arithmetic and serialization/deserialization of data is handled by the block layer and thus completely hidden from upper layers.

Generally, the block layer only manipulates a single block at a time.
Operations that span multiple blocks need to be coordinated on a higher level.
The one exception to this rule is empty space management.
Block managers are expected to keep track of empty blocks (blocks that are ready for allocation) and they generally use blocks themselves to store this information. 

As with the I/O layer, we created two implementations of the block layer.
Our actual virtual disks use the \texttt{Panda.Core.IO.RawBlockManager}, which is backed by a \texttt{IRawPersistenceSpace} (in memory or based on a memory mapped file).
That implementation persists blocks into the unmanaged memory provided by the raw block manager.

The second implementation, \texttt{Panda.Test.InMemory.Blocks}, simply models blocks as a collection plain old C\# objects.
Again, this second implementation proved very useful, because we were able to test the implementation of the upper layer before our \texttt{RawBlockManager} was ready for prime time.

\subsubsection{Filesystem layer}

This is the most abstract level. 
Here we implement the most of the actual functionality of the file system in terms of the block API.

This layer needs to worry about how the many different blocks relate to one another.
For instance, if the block that is backing a large directory has not enough room for another directory entry, the file system is responsible for allocating an overflow or ``continuation'' block and spill the new entry there.

The most important Classes are the VirtualDirectory.cs and VirtualFile.cs which inherit from VirtualNode.cs. With the node concept we realize the fact that a directory and file have many things in commen (they can be renamed, deleted, etc.). Due to the integration of an enumerator we can access a list of nodes very efficiently.\\

The methods related to this abstraction level are stored in Panda.Core and  Panda.Core/Core/Internal.







\section{Requirements}

Each requirement which is listed is also implemented. The software elements which are involved can be found in the test class \hbox{Panda.Test/Integration/Specification.cs}. The test method is noted to each requirement.

\begin{enumerate}
	\item \emph{The virtual disk must be stored in a single file in the working directory in the host file system.}\\
		The whole VFS is stored in the instance disk which is created at the beginning.\\
		Test method: Req2\_1\_1\_and\_2
	\item \emph{VFS must support the creation of a new disk with the specified maximum size at the specified
location in the host file system.}\\
		Possible since we can create a VFS.\\
		Test method: Req2\_1\_1\_and\_2
	\item \emph{VFS must support several virtual disks in the host file system.}\\
		We can create n different disks with different files.\\
		Test method: Req2\_1\_3
	\item \emph{VFS must support disposing of the virtual disk.}\\
		Possible with Dispose().\\
		Test method: Req2\_1\_4
	\item \emph{VFS must support creating/deleting/renaming directories and files.}\\
		Files support all these methods after they are created.\\
		Test method: Req2\_1\_5
	\item \emph{VFS must support navigation: listing of files and folders, and going to a location expressed by a
concrete path.}\\
		Since files and folders inherit from nodes they are stored in an list and we can loop trough them. With navigate() we can go to a concrete path, absolute or relative.\\
		Test method: Req2\_1\_6
	\item \emph{VFS must support moving/copying directories and files, including hierarchy.}\\
		move() and copy() are implemented.\\
		Test method: Req2\_1\_7
	\item \emph{VFS must support importing files and directories from the host file system.}\\
		import() is implemented and reads from the System.IO.Stream.\\
		Test method: Req2\_1\_8\_and\_9
	\item \emph{VFS must support exporting files and directories to the host file system.}\\
		import() is implemented and writes to System.IO.Stream.\\
		Test method: Req2\_1\_8\_and\_9
	\item \emph{VFS must support querying of free/occupied space in the virtual disk.}\\
		Size is implemented as field of directories and files. To get the occupied space just ask root.\\
		Test method: Req2\_1\_10
	\item \textbf{Bonus Basic:} \emph{Elastic disk: Virtual disk can dynamically grow or shrink, depending on its occupied space.}\\
		The internal data structure can already grow and shrink dynamically since we work with blocks.
	\item \textbf{Bonus Advanced:} \emph{Large data: This means, that VFS core can store \& operate amount of data, that can't fit to PC RAM ( typically, more than 4Gb).}\\
		To fulfill this taks we decided to work with a block structure. This implies automaticaly that we can store more than 4Gb.\\
\end{enumerate}

\section{Implementation details}\label{sct:impl}

This section lists the detailed specification of the block system of the virtual file system.

\subsubsection{General Remarks}

\begin{itemize}
	\item Offsets \& lengths in bytes.
	\item The VFS is organized in blocks with fixed BLOCK\_SIZE.
	\item All addresses are in number of blocks from 0 and of length 4 bytes.
	\item Only single links to blocks (not more than one hard-link) are allowed. This means that one file or directory can only be in one directory.
	\item Block address 0 is illegal, it means absence of a block.
	\item B\_S := BLOCK\_SIZE \& d-t := data-type
	\item Offsets are absolute
	\item Strings are encoded in UTF-8
\end{itemize}

\subsubsection{Metadata}

Metadata of the whole VFS starts at address 0.\\

\begin{tabular}{|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{7cm}|}\hline
Offset 	&Length	&C\# d-t	&Description\\\hline
0	&4	&UInt32	&Number of blocks in entire VFS\\
4	&4	&UInt32	&BLOCK\_SIZE in bytes\\
8	&4	&UInt32	&Address of root directory node\\
12	&4	&UInt32	&Address of empty page block. Must never be 0\\
16	&4	&UInt32	&“break” in number of blocks, see empty space management.\\
20	&B\_S -20	&UInt32	&Empty (initialized with 0)\\\hline
\end{tabular}\\

Normal blocks are everywhere but at address 0.

\paragraph{Block Types}

\begin{itemize}
	\item Directory blocks (many different blocks, with optional continuation blocks)
	\item File blocks (many different blocks, with optional continuation blocks)
	\item Data blocks (many different blocks)
	\item Empty space block (exactly one block, with optional continuation blocks)
\end{itemize}

\subparagraph{Directory blocks} \mbox{} \\

Contain file / directory names of current directory and their block addresses.\\

\begin{tabular}{|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{7cm}|}\hline
Offset 	&Length	&C\# d-t	&Description\\\hline
0	&?	&-	&Arbitrary number of directory entries\\
B\_S - 4	&4	&UInt32	&Link to directory continuation block. 0 here marks absence of continuation blocks.\\\hline
\end{tabular} \\

Directory continuation blocks look the same as directory blocks and can link to other directory continuation blocks.

\subparagraph{Directory entry} \mbox{} \\

\begin{tabular}{|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{7cm}|}\hline
Offset 	&Length	&C\# d-t	&Description\\\hline
0	&1	&UInt8	&If first bit (the least significant) set (== 1), following address points to directory. Else to file.\\
2	&1	&UInt8	&Number of bytes in file name. 0 here marks end of directory block.\\
3	&X	&String	&File / directory name\\
X	&X + 4	&UInt32	&Address to file / directory block\\\hline
\end{tabular} \\

\subparagraph{File blocks} \mbox{} \\

Contain addresses to data blocks.\\

\begin{tabular}{|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{7cm}|}\hline
Offset 	&Length	&C\# d-t	&Description\\\hline
0	&8	&UInt64	&File size in bytes (to manage files smaller than block size)\\
8	&?	&UInt32	&Arbitrary number of addresses to data blocks\\
B\_S - 4	&4	&UInt32	&Link to file continuation block. 0 here marks absence of continuation blocks.\\\hline
\end{tabular} \\

File continuation blocks have file size 0 and can link to other file continuation blocks.

\subparagraph{File blocks} \mbox{} \\

Contain only plain binary data.

\subparagraph{Empty space block} \mbox{} \\

Contains addresses to empty blocks.\\

\begin{tabular}{|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{7cm}|}\hline
Offset 	&Length	&C\# d-t	&Description\\\hline
0	&4	&UInt32	&Number of empty blocks in number of blocks\\
4	&?	&UInt32	&Arbitrary number of addresses to empty blocks\\
B\_S - 4	&4	&UInt32	&Link to empty space continuation block. 0 here marks absence of continuation blocks.\\\hline
\end{tabular} \\

\subsubsection{Empty space management}

The VFS is designed to maintain an index of unused blocks. The addresses of the unused blocks are stored in the empty space block. Its address is stored in the VFS meta-data. This empty space block may also have empty space continuation blocks. But not every address to an empty block in the whole VFS can be stored in this empty space block. Instead, only addresses of empty blocks up to a maximum address, which is called “break”, is stored in this block. If there are no empty blocks left, the “break” must be increased by 1, and the new empty block addresses must be added to the empty space block. If the block next to “break” is freed, decrease the “break”, otherwise the address of this block to the empty space block or its last continuation block.

% PART II: VFS Browser
% --------------------------------------

\section{VFS Browser}

% TODO: Remove this line
\textbf{[This section has to be completed by April 22nd.]}

%TODO: Remove this text and replace it with actual content
\emph{Give a short (1-2 paragraphs) description of what VFS Browser is.}


\subsection{Requirements}

% TODO: Remove this text and replace it with actual content
\emph{Describe which requirements (and possibly bonus requirements) you have implemented in this part. Give a quick description (1-2 sentences) of each requirement. List the software elements (classes and or functions) that are mainly involved in implementing each requirement.}


\subsection{Design}

% TODO: Remove this text and replace it with actual content
\emph{Give an overview of the design of this part and describe in general terms how the implementation works. You can mention design patterns used, class diagrams, definition of custom file formats, network protocols, or anything else that helps understand the implementation.}


\subsection{Integration}

% TODO: Remove this text and replace it with actual content
\emph{If you had to change the design or API of the previous part, describe the changes and the reasons for each change here.}



% PART III: Synchronization Server
% --------------------------------------

\section{Synchronization Server}

% TODO: Remove this line
\textbf{[This section has to be completed by May 13th.]}

%TODO: Remove this text and replace it with actual content
\emph{Give a short (1-2 paragraphs) description of what VFS Browser is.}


\subsection{Requirements}

% TODO: Remove this text and replace it with actual content
\emph{Describe which requirements (and possibly bonus requirements) you have implemented in this part. Give a quick description (1-2 sentences) of each requirement. List the software elements (classes and or functions) that are mainly involved in implementing each requirement.}


\subsection{Design}

% TODO: Remove this text and replace it with actual content
\emph{Give an overview of the design of this part and describe in general terms how the implementation works. You can mention design patterns used, class diagrams, definition of custom file formats, network protocols, or anything else that helps understand the implementation.}


\subsection{Integration}

% TODO: Remove this text and replace it with actual content
\emph{If you had to change the design or API of the previous part, describe the changes and the reasons for each change here.}



% PART IV: Quick Start Guide
% --------------------------------------

\section{Quick Start Guide}

% TODO: Remove this line
\textbf{[optional: This part has to be completed by April 8th.]}

% TODO: Remove this text and replace it with actual content
\emph{If you have a command line interface for your VFS, describe here the commands available (e.g. ls, copy, import).} \\ \\ \\


% TODO: Remove this line
\noindent\textbf{[This part has to be completed by May 13th.]}

% TODO: Remove this text and replace it with actual content
\emph{Describe how to realize the following use case with your system. Describe the steps involved and how to perform each action (e.g. command line executions and arguments, menu entries, keyboard shortcuts, screenshots). The use case is the following:
\begin{enumerate}
\item Start synchronization server on localhost.
\item Create account on synchronization server.
\item Create two VFS disks (on the same machine) and link them to the new account.
\item Import a directory (recursively) from the host file system into Disk 1.
\item Dispose Disk 1 after the synchronization finished.
\item Export the directory (recursively) from Disk 2 into the host file system.
\item Stop synchronization server.
\end{enumerate}
}


\end{document}
