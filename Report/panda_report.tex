\documentclass[a4paper,12pt]{article}

% !TeX program = pdfLaTeX

% add more packages if necessary
\usepackage{xspace}
%\usepackage{graphicx}
%\usepackage{xcolor}
%\usepackage{hyperref}


\newcommand{\groupname}{Panda\xspace}


\title{
Project Report \\ 
Group Pandas \\
\vspace{5mm}
\large Java and C\# in depth, Spring 2013
}
\author{
Christian Klauser \\
Sander Schaffner \\
Roger Walt
}
\date{\today}



\begin{document}
\maketitle

\section{Introduction}

This document describes the design and implementation of the \emph{Panda Virtual File System} of group \emph{Pandas}. The project is part of the course \emph{Java and C\# in depth} at ETH Zurich. The following sections describe each project phase, listing the requirements that were implemented and the design decisions taken. The last section describes a use case of using the \emph{Panda Virtual File System}.

% PART I: VFS CORE
% --------------------------------------

\section{VFS Core}

The VFS Core (assembly Panda.Core) is the actual implementation of the virtual file system. It is a library that manages directories and files within virtual as we are used to it from other file systems. Clients are presented with a simple API that models the virtual file system as a hierarchical structure. Implementation details are well hidden and the libraries design lends itself to isolated testing of its individual components.

\subsection{Design}

%\emph{Give an overview of the design of this part and describe in general terms how the implementation works. You can mention design patterns used, class diagrams, definition of custom file formats, network protocols, or anything else that helps understand the implementation.}\\

The VFS Core is divided in three layers. 
This makes the library easier to understand and maintain, as the individual layers need not concern themselves with the entire complexity of virtual file systems as a whole.

We chose to simplify storage management by dividing the available space in a virtual disk into evenly sized \emph{blocks}. 
One of our layers, the block API, is exclusively task with the reading and writing of these blocks to and from ``raw'' storage space. 
The boundaries of the block layer define the two other layers: the file system layer, implemented on top of the block API, and the I/O layer, which manages the actual storage (reading/writing from the host file system)

\subsubsection{I/O layer}

On this level we store raw data. Implementations of the I/O layer implement the \texttt{IPersistenceSpace} and \texttt{IRawPersistenceSpace} interfaces in the \texttt{Panda.Core.IO} namespace. 
Our main implementation uses \emph{memory mapped files} to read from and write to the disk.
From the perspective of the block layer, a \emph{storage space} is simply a large block of main memory that gets ``magically'' persisted to disk.
The I/O abstraction is not perfect, as it hands out raw (unsafe) pointers and therefore must be backed by contiguous memory.

For debugging and unit testing purposes, we also implemented a persistence space that is not backed by a file on disk.
This has proven useful as we did not have to deal with the creation and clean up of temporary files.

\subsubsection{Block layer}

The purpose of the block layer is to present a structured view of the raw storage space below. 
It divides the underlying space into evenly sized block (block size can be configured per disk), which it uses to store both file system meta information as well as the actual file contents themselves.

Blocks are addressed by their index (how many blocks come before them) as opposed to their absolute byte offset.
This addressing has the advantage that it is independent of the underlying block size. 

The block layer is exposed via the interface \texttt{Panda.Core.Blocks.IBlockManager}.
Implementations of this interface hand out instances of \texttt{Panda.Core.Blocks.IBlock} (or derived interfaces), which are each responsible for a single block of the virtual disk.

Given such an \texttt{IBlock}, the user can read/write fields of the block in a safe manner. 
Pointer arithmetic and serialization/deserialization of data is handled by the block layer and thus completely hidden from upper layers.

Generally, the block layer only manipulates a single block at a time.
Operations that span multiple blocks need to be coordinated on a higher level.
The one exception to this rule is empty space management.
Block managers are expected to keep track of empty blocks (blocks that are ready for allocation) and they generally use blocks themselves to store this information. 

As with the I/O layer, we created two implementations of the block layer.
Our actual virtual disks use the \texttt{Panda.Core.IO.RawBlockManager}, which is backed by a \texttt{IRawPersistenceSpace} (in memory or based on a memory mapped file).
That implementation persists blocks into the unmanaged memory provided by the raw block manager.

The second implementation, \texttt{Panda.Test.InMemory.Blocks}, simply models blocks as a collection plain old C\# objects.
Again, this second implementation proved very useful, because we were able to test the implementation of the upper layer before our \texttt{RawBlockManager} was ready for prime time.

\subsubsection{Filesystem layer}

This is the most abstract level. 
Here we implement the most of the actual functionality of the file system in terms of the block API.

This layer needs to worry about how the many different blocks relate to one another.
For instance, if the block that is backing a large directory has not enough room for another directory entry, the file system is responsible for allocating an overflow or ``continuation'' block and spill the new entry there.

When implementing the file system API, we chose to follow the composite pattern. 
We have \texttt{VirtualFile} as the leaf and \texttt{VirtualDirectory} as the inner node of our virtual directory tree (both inherit from \texttt{VirtualNode}).
Common operations like move, rename, delete are of course available on the \texttt{VirtualNode}-level.

The API that users of the Core consume is located in the \texttt{Panda} namespace whereas our implementation can be found in the \texttt{Panda.Core.Internal} namespace. 

The entire system is wired up (instantiating persistence spaces, supplying them to block managers and injecting those into virtual disk implementations) by a pair of factory methods in \texttt{VirtualDisk}.

\section{VFS Core Requirements}

Each requirement which is listed is also implemented. The software elements which are involved can be found in the test class \hbox{Panda.Test/Integration/Specification.cs}. The test method is noted to each requirement.

\begin{enumerate}
	\item \emph{The virtual disk must be stored in a single file in the working directory in the host file system.}\\
		The whole VFS is stored in the instance disk which is created at the beginning.\\
		While our system defaults to creating disks in the process's working directory, it is not limited to that directory.
		 All information about a virtual disk is stored as part of that virtual disk. As a consequence, we also do not have a central list of existing virtual disks. \\
		The actual storage is handled by \texttt{Panda.Core.IO.MemoryMapped.}\\\texttt{MemoryMappedFileSpace} whereas the file format is implemented by \texttt{Panda.Core.IO. RawBlockManager}.\\
		Test method: Req2\_1\_1\_and\_2
	\item \emph{VFS must support the creation of a new disk with the specified maximum size at the specified
location in the host file system.}\\
		Possible since we can create a VFS.\\
		Our implementation currently stores the maximum disk capacity as part of the disk, but also pre-allocates the virtual disk file to that size. 
		Test method: Req2\_1\_1\_and\_2
	\item \emph{VFS must support several virtual disks in the host file system.}\\
		We can create any number of different disks each with its own file.\\
		Disks are completely isolated from one another. Exchanging files and directories means exporting from one disk and importing into the other. \\
		Test method: Req2\_1\_3
	\item \emph{VFS must support disposing of the virtual disk.}\\
		Possible with Dispose().\\
		Test method: Req2\_1\_4
	\item \emph{VFS must support creating/deleting/renaming directories and files.}\\
		Files and directories support all these methods after they are created.\\
		See \texttt{VirtualFileImpl} and \texttt{VirtualDirectoryImpl}.\\
		Test method: Req2\_1\_5
	\item \emph{VFS must support navigation: listing of files and folders, and going to a location expressed by a
concrete path.}\\
		Since files and folders inherit from nodes they are stored in an list and we can loop trough them. With the method \texttt{Navigate()} on \texttt{VirtualDirectory} (implemented in \texttt{VirtualDirectoryImpl}) we can go to any concrete path, absolute or relative.\\
		Test method: Req2\_1\_6
	\item \emph{VFS must support moving/copying directories and files, including hierarchy.}\\
		\texttt{Move()} and \texttt{Copy()} are implemented as methods on \texttt{VirtualNode}.\\
		Test method: Req2\_1\_7
	\item \emph{VFS must support importing files and directories from the host file system.}\\
		\texttt{Import()} is implemented on \texttt{VirtualDirectoryImpl}. It imports host directories recursively and uses our \texttt{System.IO.Stream}-based\\\texttt{CreateFile} method to import files.\\
		Test method: Req2\_1\_8\_and\_9
	\item \emph{VFS must support exporting files and directories to the host file system.}\\
		\texttt{Export()} is implemented as a method on \texttt{VirtualNode} and works recursively for virtual directories and via our own (read-only) \texttt{Stream} for virtual files.\\
		Test method: Req2\_1\_8\_and\_9
	\item \emph{VFS must support querying of free/occupied space in the virtual disk.}\\
		Size is implemented as by recursively querying the individual directories. To get the occupied space just ask root.\\
		Test method: Req2\_1\_10
	\item \textbf{Bonus Basic:} \emph{Elastic disk: Virtual disk can dynamically grow or shrink, depending on its occupied space.}\\
		The internal data structure can already grow and shrink dynamically. 
Section \ref{sct:empty} discusses how keep track of how much space our file system actually needs.
However, at this time, the space on disk is pre-allocated to the capacity that the user specified and our disk refuses to grow beyond that size.
	\item \textbf{Bonus Advanced:} \emph{Large data: This means, that VFS core can store \& operate amount of data, that can't fit to PC RAM ( typically, more than 4Gb).}\\
		We use the operating system's virtual memory mechanism to get the relevant pieces of our file system in memory. 
We were careful not to hold on to data structures (blocks, virtual nodes) but instead re-create them whenever required.
That way, our file system implementation only uses as much RAM as the user wielding it.

We do, however, require a 64bit virtual address space to operate on large files. 
While it would be technically possible to map just parts of a large file into the much smaller 32bit address space, we chose not implement re-mapping.
\end{enumerate}

\section{Implementation details}\label{sct:impl}

This section lists the detailed specification of the block system of the virtual file system.

\subsection{General Remarks}

\begin{itemize}
	\item Offsets \& lengths in bytes.
	\item The VFS is organized in blocks with fixed BLOCK\_SIZE.
	\item All addresses are in number of blocks from 0 and of length 4 bytes.
	\item Only single links to blocks (not more than one hard-link) are allowed. This means that one file or directory can only be in one directory.
	\item Block address 0 is illegal, it means absence of a block.
	\item B\_S := BLOCK\_SIZE \& d-t := data-type
	\item Offsets are absolute
	\item Strings are encoded in UTF-8
\end{itemize}

\subsection{Metadata}

Metadata of the whole VFS starts at address 0.\\

\begin{tabular}{|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{7cm}|}\hline
Offset 	&Length	&C\# d-t	&Description\\\hline
0	&4	&UInt32	&Number of blocks in entire VFS\\
4	&4	&UInt32	&BLOCK\_SIZE in bytes\\
8	&4	&UInt32	&Address of root directory node\\
12	&4	&UInt32	&Address of empty page block. Must never be 0\\
16	&4	&UInt32	&“break” in number of blocks, see empty space management.\\
20	&B\_S -20	&UInt32	&Empty (initialized with 0)\\\hline
\end{tabular}\\

Normal blocks are everywhere but at address 0.

\paragraph{Block Types}

\begin{itemize}
	\item Directory blocks (many different blocks, with optional continuation blocks)
	\item File blocks (many different blocks, with optional continuation blocks)
	\item Data blocks (many different blocks)
	\item Empty space block (exactly one block, with optional continuation blocks)
\end{itemize}

\subparagraph{Directory blocks} \mbox{} \\

Contain file / directory names of current directory and their block addresses.\\

\begin{tabular}{|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{7cm}|}\hline
Offset 	&Length	&C\# d-t	&Description\\\hline
0	&?	&-	&Arbitrary number of directory entries\\
B\_S - 4	&4	&UInt32	&Link to directory continuation block. 0 here marks absence of continuation blocks.\\\hline
\end{tabular} \\

Directory continuation blocks look the same as directory blocks and can link to other directory continuation blocks.

\subparagraph{Directory entry} \mbox{} \\

\begin{tabular}{|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{7cm}|}\hline
Offset 	&Length	&C\# d-t	&Description\\\hline
0	&1	&UInt8	&If first bit (the least significant) set (== 1), following address points to directory. Else to file.\\
2	&1	&UInt8	&Number of bytes in file name. 0 here marks end of directory block.\\
3	&X	&String	&File / directory name\\
X	&X + 4	&UInt32	&Address to file / directory block\\\hline
\end{tabular} \\

\subparagraph{File blocks} \mbox{} \\

Contain addresses to data blocks.\\

\begin{tabular}{|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{7cm}|}\hline
Offset 	&Length	&C\# d-t	&Description\\\hline
0	&8	&UInt64	&File size in bytes (to manage files smaller than block size)\\
8	&?	&UInt32	&Arbitrary number of addresses to data blocks\\
B\_S - 4	&4	&UInt32	&Link to file continuation block. 0 here marks absence of continuation blocks.\\\hline
\end{tabular} \\

File continuation blocks have file size 0 and can link to other file continuation blocks.

\subparagraph{File blocks} \mbox{} \\

Contain only plain binary data.

\subparagraph{Empty space block} \mbox{} \\

Contains addresses to empty blocks.\\

\begin{tabular}{|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{7cm}|}\hline
Offset 	&Length	&C\# d-t	&Description\\\hline
0	&4	&UInt32	&Number of empty blocks in number of blocks\\
4	&?	&UInt32	&Arbitrary number of addresses to empty blocks\\
B\_S - 4	&4	&UInt32	&Link to empty space continuation block. 0 here marks absence of continuation blocks.\\\hline
\end{tabular} \\

\subsection{Empty space management}\label{sct:empty}

The VFS is designed to maintain an index of unused blocks. The addresses of the unused blocks are stored in the empty space block. Its address is stored in the VFS meta-data. This empty space block may also have empty space continuation blocks. But not every address to an empty block in the whole VFS can be stored in this empty space block. Instead, only addresses of empty blocks up to a maximum address, which is called “break”, is stored in this block. If there are no empty blocks left, the “break” must be increased by 1, and the new empty block addresses must be added to the empty space block. If the block next to “break” is freed, decrease the “break”, otherwise the address of this block to the empty space block or its last continuation block.

% PART II: VFS Browser
% --------------------------------------

\section{VFS Browser}

The VFS Browser is a Graphical User Interface which allowes the user to use all functions which are implemented in VFS Core. This can be done by mouse or keyboard. Further it is extended by a search function.

\subsection{Design}

% TODO: Remove this text and replace it with actual content
\emph{Give an overview of the design of this part and describe in general terms how the implementation works. You can mention design patterns used, class diagrams, definition of custom file formats, network protocols, or anything else that helps understand the implementation.}\\
Since our implementation is written in C\# we used WPF for our GUI. After opening the browser you get an DockPanel. We implemented a Manu on top and a StatusBar at the bottem which shows a StatusText. The actual VFS is shown as a TreeView.

\subsection{Integration}

% TODO: Remove this text and replace it with actual content
\emph{If you had to change the design or API of the previous part, describe the changes and the reasons for each change here.}


\section{VFS Browser Requirements}

% TODO: Remove this text and replace it with actual content
\emph{Describe which requirements (and possibly bonus requirements) you have implemented in this part. Give a quick description (1-2 sentences) of each requirement. List the software elements (classes and or functions) that are mainly involved in implementing each requirement.}

\begin{enumerate}
	\item \emph{The browser should be implemented on one of the following platforms: desktop, web or mobile.}\\
		Implemented as an WPF application which runs on a desktop.\\
		Test method:
	\item \emph{The browser should support all operations from Part 1 (VFS core). For example, users should be able to select a file/folder and copy it to another location without using console commands.}\\
		Possible.\\
		Test method:
	\item \emph{The browser should support both single and multiple selection of files/folders.}\\
		TODO\\
		Test method:
	\item \emph{The browser should support keyboard navigation. The mandatory set of operations includes folder navigation, going to parent and child folders (this is optional for mobile applications due to limited keyboard functionality).}\\
		TODO\\
		Test method:
	\item \emph{The browser should support mouse navigation (or touch in case of the mobile platform). The required operations are the same as in requirement 4.}\\
		Possible.\\
		Test method:
	\item \emph{The browser should support file-name search based on user-given keybwords. The search should provide options for: case sensitive/ case insensitive search; restrict search to folder; restrict search to folder and subfolders.}\\
		TODO\\
		Test method:
	\item \textbf{Bonus Basic:} \emph{Responsive UI, i.e. the browser does not stall during long-running operations (i.e. file search or import).}\\
		Works for importing files.\\
		Test method:
	\item \textbf{Bonus Basic:} \emph{Advanced search; For example, search with wildcards/regexp, and approximate search based on some metric, e.g. edit distance.}\\
		RegEx is implemented.\\
		Test method:
\end{enumerate}

% PART III: Synchronization Server
% --------------------------------------

\section{Synchronization Server}

% TODO: Remove this line
\textbf{[This section has to be completed by May 13th.]}

%TODO: Remove this text and replace it with actual content
\emph{Give a short (1-2 paragraphs) description of what VFS Browser is.}


\subsection{Requirements}

\subsection{Design}

% TODO: Remove this text and replace it with actual content
\emph{Give an overview of the design of this part and describe in general terms how the implementation works. You can mention design patterns used, class diagrams, definition of custom file formats, network protocols, or anything else that helps understand the implementation.}


\subsection{Integration}

% TODO: Remove this text and replace it with actual content
\emph{If you had to change the design or API of the previous part, describe the changes and the reasons for each change here.}



% PART IV: Quick Start Guide
% --------------------------------------

\section{Quick Start Guide}

% TODO: Remove this line
\textbf{[optional: This part has to be completed by April 8th.]}

% TODO: Remove this text and replace it with actual content
\emph{If you have a command line interface for your VFS, describe here the commands available (e.g. ls, copy, import).} \\ \\ \\


% TODO: Remove this line
\noindent\textbf{[This part has to be completed by May 13th.]}

% TODO: Remove this text and replace it with actual content
\emph{Describe how to realize the following use case with your system. Describe the steps involved and how to perform each action (e.g. command line executions and arguments, menu entries, keyboard shortcuts, screenshots). The use case is the following:
\begin{enumerate}
\item Start synchronization server on localhost.
\item Create account on synchronization server.
\item Create two VFS disks (on the same machine) and link them to the new account.
\item Import a directory (recursively) from the host file system into Disk 1.
\item Dispose Disk 1 after the synchronization finished.
\item Export the directory (recursively) from Disk 2 into the host file system.
\item Stop synchronization server.
\end{enumerate}
}


\end{document}
